// app/api/import/text/route.ts
import { NextResponse } from "next/server";

/**
 * Draft-Typ für die Antwort:
 * - title: erster sinnvoller Titel aus dem Text (oder Fallback)
 * - ingredients: grob normalisierte Zutaten-Liste
 * - steps: restlicher Text als Schritte (ohne Zutatenzeilen)
 * - servings: default 4 (kann der Nutzer später ändern)
 */
type Draft = {
  title: string;
  ingredients: { name: string; amount: number; unit: string }[];
  steps: string[];
  servings: number;
};

/** einfache Normalisierung gängiger Einheiten */
const UNIT_ALIASES: Record<string, string> = {
  g: "g",
  gr: "g",
  gramm: "g",
  grammg: "g",
  kg: "kg",
  ml: "ml",
  l: "l",
  tl: "TL",
  tsp: "TL",
  teelöffel: "TL",
  el: "EL",
  tbsp: "EL",
  esslöffel: "EL",
  stk: "Stk",
  stück: "Stk",
  prise: "Prise",
};

/** Zahl mit Komma als Dezimalpunkt erlauben */
function toNumber(s: string) {
  const n = Number(s.replace(",", "."));
  return Number.isFinite(n) ? n : NaN;
}

/**
 * Sehr einfache Heuristik zum Parsen:
 * - Zutatenzeilen beginnen oft mit -, *, •, oder "• ".
 * - Alternativ: Zeilen, die mit Zahl + evtl. Einheit starten.
 * - Restliche Zeilen werden als Schritte behandelt.
 */
function parseTextToDraft(raw: string): Draft {
  const lines = raw
    .split(/\r?\n/)
    .map((l) => l.trim())
    .filter((l) => l.length > 0);

  // Titel: erste Nicht-Listenzeile, die nicht "Zutaten" / "Zubereitung" ist
  const title =
    lines.find(
      (l) =>
        !/^(zutaten|ingredients|zubereitung|anleitung|steps)\b/i.test(l) &&
        !/^[-*•]/.test(l) &&
        !/^\d/.test(l)
    ) || "Unbenanntes Rezept";

  const ingredients: Draft["ingredients"] = [];
  const steps: string[] = [];

  for (const line of lines) {
    // offensichtliche Zutatenbullets
    const bullet = line.replace(/^[-*•]\s+/, "");

    // Versuche: "200 g Zucker", "1 EL Öl", "2 Eier"
    const m =
      bullet.match(
        /^(\d+(?:[.,]\d+)?)\s*([a-zA-ZäöüÄÖÜ]+)?\s*(.+)$/
      ) ||
      line.match(/^(\d+(?:[.,]\d+)?)\s*([a-zA-ZäöüÄÖÜ]+)?\s*(.+)$/);

    const looksLikeIngredient =
      /^[-*•]\s+/.test(line) ||
      // oder beginnt mit Menge
      /^\d/.test(line);

    if (looksLikeIngredient && m) {
      const amount = toNumber(m[1]);
      const unitRaw = (m[2] || "").toLowerCase();
      const unit = UNIT_ALIASES[unitRaw] ?? (unitRaw || "");
      const name = (m[3] || "").trim();
      ingredients.push({
        amount: Number.isFinite(amount) ? amount : 0,
        unit,
        name: name || bullet,
      });
    } else if (
      // Headings nicht in Schritte aufnehmen
      !/^(zutaten|ingredients|zubereitung|anleitung|steps)\b/i.test(line)
    ) {
      steps.push(line);
    }
  }

  // Fallback: wenn keine Schritte erkannt, alles außer Ingredients als ein Block nehmen
  if (steps.length === 0) {
    const nonIng = lines.filter((l) => !/^[-*•]\s+/.test(l));
    if (nonIng.length) steps.push(nonIng.join(" "));
  }

  return {
    title,
    ingredients,
    steps,
    servings: 4,
  };
}

export async function POST(req: Request) {
  let body: any = {};
  try {
    body = await req.json();
  } catch {
    return NextResponse.json(
      { error: "Invalid JSON body. Expected { text: string }." },
      { status: 400 }
    );
  }

  const { text } = body as { text?: string };
  if (!text || typeof text !== "string" || text.trim() === "") {
    return NextResponse.json(
      { error: "Missing { text } in request body." },
      { status: 400 }
    );
  }

  const draft = parseTextToDraft(text);
  return NextResponse.json(draft);
}